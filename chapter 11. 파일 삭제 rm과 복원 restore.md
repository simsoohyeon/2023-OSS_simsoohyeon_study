# 1. 파일 삭제 rm
## 🟢 리눅스 명령 파일 삭제
  - 작업 디렉토리에서 file 삭제
## 🟢 깃 명령 파일 삭제
```
- $ git rm [file]
  - 작업 디렉토리와 스테이징 영역에서 모두 파일 삭제
    => 다음 커밋에서 지정한 file을 삭제하겠다는 의미
    => Tracked 상태의 파일을 제거하여 Untracked 상태로 만듦
- $ git rm --cached [file]
  - 스테이징 영역에서 file 삭제 => 작업 디렉토리에서는 삭제되지 않음
  - $ git ls-files 결과에서 보이지 않음 => 기본적으로 스테이징 영역의 파일 목록을 표시
```
## 🟢 작업 디렉토리와 스테이징 영역에서 파일 삭제
```
- 현재 상태: 3영역(WD와 SA, GD) 모두에 파일 f,g가 있는 상태
- 작업 디렉토리와 스테이징 영역에서 파일 g 삭제 = $ git rm g
- 삭제된 이후 깃 배시
  - 녹색: 스테이징 영역의 표시이며 깃 저장소와 비교해 삭제됨을 의미
```
## 🟢 $ git commit -m 'Delete g'
```
- 현재 상태: WD: f, SA: f, GD: f, g
- 파일 g가 삭제된 상태에서 커밋
  - 이전 커밋과 차이는 g가 삭제된 것, 커밋 이후 log show
```
# 2. 파일 복원 restore
## 🟢 $ git restore [file]
```
- 현재 상태: 3영역은 파일 f가 모두 다른 상태
- 작업 디렉토리의 파일 f를 스테이징 영역의 파일 상태로 복주
  - 작업 디렉토리에 있던 f 내용이 사라지므로 유의
  - 3영역에서 파일 f가 작업 디렉토리와 스테이징 영역의 같은 상태가 됨 ($ git restore f)
```
## 🟢 $ git restore --staged [file]
```
- 현재 상태: 3영역의 파일 f가 모두 다른 상태
- 깃 저장소의 최신 커밋 상태의  파일 f를 스테이징 영역에 복구
  - 스테이징 영역에 있던 f내용이 사라지므로 유의
  - 3영역에서 스테이징 영역의 파일 f가 깃 저장소와 같은 상태가 됨($ git restore --staged f)
```
## 🟢 깃 저장소 내용으로 한 번에 모두 복원
```
- 현재 상태: 3영역에서 파일 f가 모두 다른 상태
- 깃 저장소의 최신 커밋 상태의 파일 f를 작업 디렉토리와 스테이징 영역에 한 번에 복구
  - 파일 f가 현재 커밋 상태의 내용으로 작업 디렉토리와 스테이징 영역 모두 같은 상태가 됨
  - git restore --source=HEAD --staged --worktree f
  (--staged는 -S, --worktree는 -W 짧게 가능(둘 다 대문자))
```
## 🟢 HEAD 내용으로 작업 디렉토리 복원
```
- 현재 상태: 3영역에서 파일 f가 모두 다른 상태
- 깃 저장소의 최신 커밋 상태의 파일 f를 작업 디렉토리에 복원
  - 파일 f가 현재 커밋 상태의 내용으로 작업 디렉토리에 복사되어 동일하게 됨
  - $ git restore --source=HEAD f
```
## 🟢 $ git restore --source=HEAD^ --staged [file]
```
- 현재 상태: 3영역에서 파일 f가 모두 다른 상태
- 깃 저장소의 최신 커밋 상태의 파일 f를 스테이징 영역의 복구
  - 스테이징 영역에 있던 파일 f 내용이 사라지므로 유의
  - 3영역에서 스테이징 영역의 파일 f가 깃 저장소 영역과 같은 상태가 됨
```
## 🟢 복원 restoe 정리
```
작업 디렉토리 ==============>>> 스테이징 영역 ================>>> 깃(지역) 저장소
    WD             add                           commit
             <<<==============               <<<==============
                  restore                     restore --staged       
```  
  
